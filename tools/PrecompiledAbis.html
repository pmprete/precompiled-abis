<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/web3/1.9.0/web3.min.js' integrity='sha512-mUvdtCaVKd9dby/UnYGKMLkP3eT7EA6QNFN5iSEjvMf8TFPq2oZFIemWL46iypQcL8xYNdx7wQIA1oYnTXuYhg==' crossorigin='anonymous' referrerpolicy='no-referrer'></script>
    <link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css' rel='stylesheet' integrity='sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN' crossorigin='anonymous'>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.2/font/bootstrap-icons.min.css" integrity="sha512-D1liES3uvDpPrgk7vXR/hR/sukGn7EtDWEyvpdLsyalQYq6v6YUsTUJmku7B4rcuQ21rf0UTksw2i/2Pdjbd3g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <title>Rootstock Bridge Methods Selectors And Events Topics</title>
</head>

<style>

.bridge-button {
    width: 540px;
}

#network-selection-container {
    width: 720px;
    margin: 8px;
}

.display {
    overflow: scroll;
}

#custom-network-container {
    display: none;
}

#fixed-network-container, #custom-network-container {
    margin-top: 12px;
    margin-bottom: 12px;
}

#customNetworkCheckbox {
    cursor: pointer;
}

#customNetworkCheckboxLabel {
    cursor: pointer;
}

</style>

<body>

    <h1 class='text-center'>Rootstock Bridge Methods Selectors and Events Topics</h3>
    <h5 class='text-center'>Simple html page to get bridge methods selectors and events topics</h2>
    
    <div id='container'>

        <div id="controlsContainer">
            <div id="fixed-network-container" class="row justify-content-center align-items-center">
                <div class="col-3">
                    <b>Abis For Fork:</b>
                </div>
                <div class="col-9">
                    <select id='abiForForkSelect' class='form-select form-select-sm' aria-label=''>
                        <option selected value='fingerroot'>Fingerroot</option>
                        <option value='hop'>Hop</option>
                        <option value='iris'>Iris</option>
                        <option value='papyrus'>Papyrus</option>
                        <option value='wasabi'>Wasabi</option>
                        <option value='orchid'>Orchid</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="methodsContainer">
            <h3>Methods</h3>
            <table id="methodsTable" class="table table-bordered">
                <thead>
                  <tr>
                    <th>Method Name</th>
                    <th>Method Selector</th>
                    <th>Peg Type</th>
                    <th>Method Signature</th>
                  </tr>
                </thead>
                <tbody id="methodsTableBody"></tbody>
              </table>
        </div>

        <div id="eventsContainer">
            <h3>Events</h3>
            <table id="eventsTable" class="table table-bordered">
                <thead>
                  <tr>
                    <th>Event Name</th>
                    <th>Event Topic</th>
                    <th>Peg Type</th>
                    <th>Event Signature</th>
                  </tr>
                </thead>
                <tbody id="eventsTableBody"></tbody>
              </table>
        </div>

    </div>

<script>

    const orchidAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/1.0.0-ORCHID/abis/bridge.json';
    const wasabiAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/2.0.1-WASABI/abis/bridge.json';
    const papyrusAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/3.0.0-PAPYRUS/abis/bridge.json';
    const irisAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/4.0.2-IRIS/abis/bridge.json';
    const hopAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/5.0.0-HOP/abis/bridge.json';
    const fingerrootAbisUrl = 'https://raw.githubusercontent.com/rsksmart/precompiled-abis/5.0.0-FINGERROOT/abis/bridge.json';

    const abisForkInfoMap = {
        orchid: {
            name: '1.0.0-ORCHID',
            key: 'orchid',
            url: orchidAbisUrl
        },
        wasabi: {
            name: '2.0.1-WASABI',
            key: 'wasabi',
            url: wasabiAbisUrl
        },
        papyrus: {
            name: '3.0.0-PAPYRUS',
            key: 'papyrus',
            url: papyrusAbisUrl
        },
        iris: {
            name: '4.0.2-IRIS',
            key: 'iris',
            url: irisAbisUrl
        },
        hop: {
            name: '5.0.0-HOP',
            key: 'hop',
            url: hopAbisUrl
        },
        fingerroot: {
            name: '5.0.0-FINGERROOT',
            key: 'fingerroot',
            url: fingerrootAbisUrl
        }
    };

    const abiCache = {
        orchid: null,
        wasabi: null,
        papyrus: null,
        iris: null,
        hop: null,
        fingerroot: null
    };

    const peginMethods = [
        'registerBtcTransaction',
        'registerBtcCoinbaseTransaction',
        'registerFastBridgeBtcTransaction',
        'receiveHeaders',
        'receiveHeader',
        'getFederationAddress',
        'getLockWhitelistSize',
        'getLockWhitelistAddress',
        'getLockWhitelistEntryByAddress',
        'addLockWhitelistAddress',
        'addOneOffLockWhitelistAddress',
        'addUnlimitedLockWhitelistAddress',
        'removeLockWhitelistAddress',
        'setLockWhitelistDisableBlockDelay',
        'getMinimumLockTxValue',
        'getLockingCap',
        'increaseLockingCap',
    ];

    const peginEvents = [
        'lock_btc',
        'pegin_btc',
        'rejected_pegin',
        'unrefundable_pegin',
    ];

    const pegoutMethods = [
        'releaseBtc',
        'updateCollections',
        'addSignature',
        'getFeePerKb',
        'voteFeePerKbChange'
    ];

    const pegoutEvents = [
        'update_collections',
        'release_request_rejected',
        'release_request_received',
        'release_requested',
        'batch_pegout_created',
        'pegout_confirmed',
        'add_signature',
        'release_btc',
    ];

    let selectedAbis = null;
    let selectedAbiForkInfo = abisForkInfoMap.fingerroot;

    const testnetRskUrl = 'https://public-node.testnet.rsk.co/';
    let web3;

    const getBridgeAbi = async (forkKey) => {
        const abiUrl = abisForkInfoMap[forkKey].url;
        const response = await fetch(abiUrl);
        const bridgeAbi = await response.json();
        return bridgeAbi;
    };

    const selectAbi = async (forkKey) => {
        const forkInfo = abisForkInfoMap[forkKey];
        if(abiCache[forkKey]) {
            selectedAbis = abiCache[forkKey];
            return;
        }
        const bridgeAbi = await getBridgeAbi(forkKey);
        mapSignaturesAndSelectors(bridgeAbi);
        selectedAbis = bridgeAbi;
        abiCache[forkKey] = bridgeAbi;
    };

    const getBridgeEventTopic = (eventAbi) => {
        return web3.eth.abi.encodeEventSignature(eventAbi);
    };

    const getBridgeMethodSelector = (methodAbi) => {
        return web3.eth.abi.encodeFunctionSignature(methodAbi);
    };

    const getPegType = abi => {
        if(abi.type === 'event') {
            if(peginEvents.includes(abi.name)) {
                return 'pegin';
            } else if(pegoutEvents.includes(abi.name)) {
                return 'pegout';
            }
        } else if(abi.type === 'function') {
            if(peginMethods.includes(abi.name)) {
                return 'pegin';
            } else if(pegoutMethods.includes(abi.name)) {
                return 'pegout';
            }
        }
        return '';
    };

    const mapSignaturesAndSelectors = (abis) => {
        abis.forEach(abi => {
            if(abi.type === 'event') {
                abi.signature = getEventSignature(abi);
                abi.selector = getBridgeEventTopic(abi);
            } else if(abi.type === 'function') {
                abi.signature = getMethodSignature(abi);
                abi.selector = getBridgeMethodSelector(abi);
            }
            abi.pegType = getPegType(abi);
        });
    };

    const getEventSignature = (abi) => {
        const inputTypes = abi.inputs
            .map(input => input.type);
        const signature = `${abi.name}(${inputTypes.join(',')})`;
        return signature;
    };

    const getMethodSignature = (abi) => {
        const types = abi.inputs.map(input => input.type);
        const signature = `${abi.name}(${types.join(',')})`;
        return signature;
    };

    const getCopyIconElement = (querySelectorOfElementToCopyValueFrom) => {
        const copyIconElement = document.createElement('i');
        copyIconElement.setAttribute('class', 'bi bi-clipboard');
        copyIconElement.setAttribute('style', 'font-size: 1.5rem; cursor: pointer;');
        copyIconElement.title = 'Copy to clipboard';
        copyIconElement.onclick = (event) => {
            const displayElement = event.target.parentNode.querySelector(querySelectorOfElementToCopyValueFrom);
            const text = displayElement.innerText;
            navigator.clipboard.writeText(text);
        };
        return copyIconElement;
    };

    const getDisplayElement = () => {
        const displayElement = document.createElement('span');
        displayElement.setAttribute('class', 'mx-2 display form-control');
        displayElement.setAttribute('disabled', 'true');
        return displayElement;     
    };

    const getActionButton = (name) => {
        const button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.setAttribute('class', 'btn btn-outline-primary mr-2 bridge-button');
        button.textContent = name;
        button.onclick = handleClick;
        return button;
    };

    const getDisplaySpan = (text) => {
        const span = document.createElement('span');
        span.setAttribute('class', 'mx-2 display');
        span.innerText = text;
        return span;
    };

    const fillTable = (abis, tableId) => {

        const tableBody = document.getElementById(tableId);

        abis.forEach(abi => {

            const row = tableBody.insertRow();
            const cell1 = row.insertCell(0);
            const cell2 = row.insertCell(1);
            const cell3 = row.insertCell(2);
            const cell4 = row.insertCell(3);

            const classSelector = '.display';

            cell1.appendChild(getDisplaySpan(abi.name));

            cell2.appendChild(getDisplaySpan(abi.selector));
            cell2.appendChild(getCopyIconElement(classSelector));

            cell3.appendChild(getDisplaySpan(abi.pegType));

            cell4.appendChild(getDisplaySpan(abi.signature));
            cell4.appendChild(getCopyIconElement(classSelector));

        });
    };

    const fillEventsTable = () => {
        const events = selectedAbis.filter(abi => abi.type === 'event');
        fillTable(events, 'eventsTableBody');
    };

    const fillMethodsTable = () => {
        const methods = selectedAbis.filter(abi => abi.type === 'function');
        fillTable(methods, 'methodsTableBody');
    };

    const emptyTable = (tableId) => {
        const tableBody = document.getElementById(tableId);
        while (tableBody.firstChild) {
        tableBody.removeChild(tableBody.firstChild);
        }
    };

    const emptyMethodsTable = () => {
        emptyTable('methodsTableBody');
    };

    const emptyEventsTable = () => {
        emptyTable('eventsTableBody');
    };

    const onAbiForForkChange = async (event) => {
        emptyMethodsTable();
        emptyEventsTable();
        const forkKey = event.target.value;
        selectedAbiForkInfo = abisForkInfoMap[forkKey];
        await selectAbi(forkKey);
        fillEventsTable();
        fillMethodsTable();
    };

    abiForForkSelect.addEventListener('change', onAbiForForkChange);

    const setup = async () => {
        web3 = new Web3(testnetRskUrl);
        await selectAbi(selectedAbiForkInfo.key);
        fillEventsTable();
        fillMethodsTable();
    };

    setup().then(() => {
        console.log('Loaded.');
    })
    .catch(err => {
        console.log(err);
    });

</script>

</body>
</html>
